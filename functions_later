use crate::models::{MyLoginSession, MyOAuthToken, MyUser};
use leptos::*;
use uuid::Uuid;

#[cfg(feature = "ssr")]
fn expect_auth() -> crate::server::Userp {
    expect_context()
}

#[cfg(feature = "ssr")]
fn expect_store() -> crate::server::MemoryStore {
    expect_context()
}

#[cfg(feature = "ssr")]
fn write_auth(auth: crate::server::Userp) {
    use http::header::SET_COOKIE;
    use leptos_axum::ResponseOptions;

    let res = expect_context::<ResponseOptions>();

    for encoded in auth.get_encoded_cookies() {
        res.append_header(SET_COOKIE, encoded.parse().expect("Malformed cookie value"));
    }
}

#[server]
pub async fn get_user() -> Result<Option<MyUser>, ServerFnError> {
    let auth = expect_auth();

    Ok(auth.user().await?)
}

#[server]
pub async fn get_expected_user() -> Result<MyUser, ServerFnError> {
    let auth = expect_auth();

    match auth.user().await? {
        Some(user) => Ok(user),
        None => Err(ServerFnError::ServerError("Unauthorized".into())),
    }
}

#[server]
pub async fn login_with_password(
    email: String,
    password: String,
    next: Option<String>,
) -> Result<Result<(), String>, ServerFnError> {
    use leptos_axum::redirect;
    use userp::prelude::*;

    let auth = expect_auth();

    match auth.password_login(&email, &password).await {
        Ok(auth) => {
            write_auth(auth);

            Ok(Ok(match next {
                Some(next) => redirect(next.as_str()),
                None => redirect("/dashboard"),
            }))
        }
        Err(err) => match err {
            PasswordLoginError::NotAllowed => Ok(Err("Not allowed".into())),
            PasswordLoginError::NoUser => Ok(Err("No user".into())),
            PasswordLoginError::WrongPassword => Ok(Err("Wrong password".into())),
            PasswordLoginError::StoreError(err) => {
                logging::error!("{err}");

                Err(ServerFnError::ServerError(
                    "Something went horribly wrong".into(),
                ))
            }
        },
    }
}

#[server]
pub async fn login_with_provider(
    provider: String,
    next: Option<String>,
) -> Result<Result<(), String>, ServerFnError> {
    use leptos_axum::redirect;
    use userp::prelude::*;

    match expect_auth().oauth_login_init(provider, next).await {
        Ok((auth, url)) => {
            write_auth(auth);

            Ok(Ok(redirect(url.as_str())))
        }
        Err(err) => match err {
            OAuthLoginInitError::NotAllowed => Ok(Err("Not allowed".into())),
            OAuthLoginInitError::ProviderNotFound(provider) => Err(ServerFnError::ServerError(
                format!("Provider not found: {provider}"),
            )),
        },
    }
}

#[server]
pub async fn login_with_email(
    email: String,
    next: Option<String>,
) -> Result<Result<(), String>, ServerFnError> {
    use userp::prelude::*;

    match expect_auth().email_login_init(email, next).await {
        Ok(()) => Ok(Ok(())),
        Err(err) => match err {
            EmailLoginInitError::NotAllowed => Ok(Err("Not allowed".into())),
            EmailLoginInitError::SendingEmail(err) => {
                logging::error!("{err:?}");
                Err(ServerFnError::ServerError(format!(
                    "Something went terribly wrong"
                )))
            }
        },
    }
}

#[server]
pub async fn logout(next: Option<String>) -> Result<(), ServerFnError> {
    use leptos_axum::redirect;

    match expect_auth().log_out().await {
        Ok(auth) => {
            write_auth(auth);

            Ok(match next {
                Some(next) => redirect(&next),
                None => redirect("/login"),
            })
        }
        Err(err) => {
            logging::error!("{err:#?}");
            Err(ServerFnError::ServerError("Something went wrong".into()))
        }
    }
}

#[server]
pub async fn get_oauth_tokens() -> Result<Vec<MyOAuthToken>, ServerFnError> {
    use userp::prelude::*;

    let auth = expect_auth();
    let store = expect_store();

    match auth.user().await {
        Ok(Some(user)) => match store.get_user_oauth_tokens(user.id).await {
            Ok(tokens) => Ok(tokens),
            Err(err) => {
                logging::error!("{err:#?}");
                Err(ServerFnError::ServerError("Something went wrong".into()))
            }
        },
        Ok(None) => Err(ServerFnError::ServerError("Unauthorized".into())),
        Err(err) => {
            logging::error!("{err:#?}");
            Err(ServerFnError::ServerError("Something went wrong".into()))
        }
    }
}

#[server]
pub async fn get_auth_sessions() -> Result<Vec<MyLoginSession>, ServerFnError> {
    use userp::prelude::*;

    let auth = expect_auth();
    let store = expect_store();

    match auth.user().await {
        Ok(Some(user)) => match store.get_user_sessions(user.id).await {
            Ok(sessions) => Ok(sessions),
            Err(err) => {
                logging::error!("{err:#?}");
                Err(ServerFnError::ServerError("Something went wrong".into()))
            }
        },
        Ok(None) => Err(ServerFnError::ServerError("Unauthorized".into())),
        Err(err) => {
            logging::error!("{err:#?}");
            Err(ServerFnError::ServerError("Something went wrong".into()))
        }
    }
}

#[server]
pub async fn delete_oauth_token(token_id: Uuid) -> Result<(), ServerFnError> {
    use userp::prelude::*;

    let auth = expect_auth();
    let store = expect_store();

    match auth.user().await {
        Ok(Some(user)) => match store.delete_oauth_token(user.id, token_id).await {
            Ok(sessions) => Ok(sessions),
            Err(err) => {
                logging::error!("{err:#?}");
                Err(ServerFnError::ServerError("Something went wrong".into()))
            }
        },
        Ok(None) => Err(ServerFnError::ServerError("Unauthorized".into())),
        Err(err) => {
            logging::error!("{err:#?}");
            Err(ServerFnError::ServerError("Something went wrong".into()))
        }
    }
}

#[server]
pub async fn delete_password() -> Result<(), ServerFnError> {
    use userp::prelude::*;

    let auth = expect_auth();
    let store = expect_store();

    match auth.user_session().await {
        Ok(Some((user, session))) => {
            match store.clear_user_password_hash(user.id, session.id).await {
                Ok(sessions) => Ok(sessions),
                Err(err) => {
                    logging::error!("{err:#?}");
                    Err(ServerFnError::ServerError("Something went wrong".into()))
                }
            }
        }
        Ok(None) => Err(ServerFnError::ServerError("Unauthorized".into())),
        Err(err) => {
            logging::error!("{err:#?}");
            Err(ServerFnError::ServerError("Something went wrong".into()))
        }
    }
}

#[server]
pub async fn set_allow_email_login(address: String, allow: bool) -> Result<(), ServerFnError> {
    use userp::prelude::*;

    let auth = expect_auth();
    let store = expect_store();

    match auth.user().await {
        Ok(Some(user)) => match store
            .set_user_email_allow_link_login(user.id, address, allow)
            .await
        {
            Ok(sessions) => Ok(sessions),
            Err(err) => {
                logging::error!("{err:#?}");
                Err(ServerFnError::ServerError("Something went wrong".into()))
            }
        },
        Ok(None) => Err(ServerFnError::ServerError("Unauthorized".into())),
        Err(err) => {
            logging::error!("{err:#?}");
            Err(ServerFnError::ServerError("Something went wrong".into()))
        }
    }
}

#[server]
pub async fn delete_session(session_id: Uuid) -> Result<(), ServerFnError> {
    use userp::prelude::*;

    let auth = expect_auth();
    let store = expect_store();

    match auth.user().await {
        Ok(Some(user)) => match store.delete_session(user.id, session_id).await {
            Ok(sessions) => Ok(sessions),
            Err(err) => {
                logging::error!("{err:#?}");
                Err(ServerFnError::ServerError("Something went wrong".into()))
            }
        },
        Ok(None) => Err(ServerFnError::ServerError("Unauthorized".into())),
        Err(err) => {
            logging::error!("{err:#?}");
            Err(ServerFnError::ServerError("Something went wrong".into()))
        }
    }
}
